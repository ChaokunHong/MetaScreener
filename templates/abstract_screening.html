{% extends "base.html" %}

{% block title %}Abstract Screening Actions - AI Literature Screening Assistant{% endblock %}

{% block extra_head %}
<style>
    .input-group-append .btn {
        padding-top: 0.25rem; /* Align clear button better */
        padding-bottom: 0.25rem;
    }
    .clear-input-btn {
        font-size: 0.8em;
        line-height: 1;
        opacity: 0.6;
    }
    .clear-input-btn:hover {
        opacity: 1;
    }
    
    /* 决定结果的颜色样式 */
    .log-decision-INCLUDE, .log-decision-include {
        color: #28a745;
        font-weight: bold;
    }
    .log-decision-EXCLUDE, .log-decision-exclude {
        color: #dc3545;
        font-weight: bold;
    }
    .log-decision-MAYBE, .log-decision-maybe {
        color: #ffc107;
        font-weight: bold;
    }
    .log-decision-ERROR, .log-decision-API_ERROR, .log-decision-PROCESSING_ERROR, 
    .log-decision-PROMPT_ERROR, .log-decision-TEXT_EXTRACT_ERROR, .log-decision-FILE_PROCESSING_ERROR,
    .log-decision-TIMEOUT_ERROR, .log-decision-ITEM_ERROR, .log-decision-LOOP_ERROR, 
    .log-decision-error {
        color: #a94442;
        font-weight: bold;
    }
    
    /* 渐变按钮样式 */
    .gradient-btn {
        background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
        color: white !important;
        border: none;
        padding: 0.3rem 0.7rem;
        border-radius: 4px;
        font-weight: 500;
        box-shadow: 0 2px 4px rgba(123, 44, 191, 0.2);
        transition: all 0.2s ease;
    }
    
    .gradient-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 3px 6px rgba(123, 44, 191, 0.3);
        color: white !important;
    }
    
    .gradient-btn:active {
        transform: translateY(0);
        box-shadow: 0 1px 3px rgba(123, 44, 191, 0.2);
    }
    
    /* 标题样式 */
    .test-screening-title {
        background-color: rgba(23, 162, 184, 0.25); /* 淡蓝色背景，增加深度 */
        color: #212529; /* 黑色文字 */
        padding: 0.6rem 1rem;
        margin: -1rem -1rem 1rem -1rem;
        border-bottom: 1px solid rgba(23, 162, 184, 0.4);
        border-radius: 6px 6px 0 0;
        font-size: 1.1rem;
    }
    
    .full-screening-title {
        background-color: rgba(40, 167, 69, 0.25); /* 淡绿色背景，增加深度 */
        color: #212529; /* 黑色文字 */
        padding: 0.6rem 1rem;
        margin: -1rem -1rem 1rem -1rem;
        border-bottom: 1px solid rgba(40, 167, 69, 0.4);
        border-radius: 6px 6px 0 0;
        font-size: 1.1rem;
    }
    
    /* 增加卡片间距 */
    .section-card {
        margin-bottom: 7rem;
    }
    
    /* 减小进度区域标题字体 */
    #test_progress_area h4, #progress_area h4 {
        font-size: 0.95rem;
        font-weight: 600;
        color: #555;
    }
</style>
{% endblock %}

{% block content %}
{# --- Test Screening Section --- #}
<div class="section-card">
    <h2 class="test-screening-title">Test Screening (Sampled Abstracts)</h2>
    <p>Upload a .ris file to screen a sample of abstracts with progress updates. Compare AI decisions and view metrics.</p>
    <form id="test_screen_form" enctype="multipart/form-data"> 
        <div class="form-row">
            <div class="form-group col-md-5">
                <label for="test_file">Upload RIS File:</label>
                <input type="file" name="file" id="test_file" class="form-control-file form-control-sm" required accept=".ris">
            </div>
            <div class="form-group col-md-2">
                <label for="sample_size">Sample Size:</label> 
                <input type="number" name="sample_size" id="sample_size" class="form-control form-control-sm" value="10" min="5" max="9999">
            </div>
        </div>
        <!-- NEW FILTER FIELDS for Test Screening -->
        <div class="form-row">
            <div class="form-group col-md-6">
                <label for="test_title_text_filter">Filter by Title (Optional):</label>
                <div class="input-group input-group-sm">
                    <input type="text" id="test_title_text_filter" name="title_text_filter" class="form-control form-control-sm" placeholder="Enter keywords from title">
                    <div class="input-group-append">
                        <button class="btn btn-outline-secondary clear-input-btn" type="button" onclick="clearInput('test_title_text_filter')">&times;</button>
                    </div>
                </div>
            </div>
            <div class="form-group col-md-6">
                <label for="test_line_range_filter">Filter by Line Numbers (Optional, 1-based):</label>
                <div class="input-group input-group-sm">
                    <input type="text" id="test_line_range_filter" name="line_range_filter" class="form-control form-control-sm" placeholder="e.g., 5-10, 7, 1-20, 50-">
                    <div class="input-group-append">
                        <button class="btn btn-outline-secondary clear-input-btn" type="button" onclick="clearInput('test_line_range_filter')">&times;</button>
                    </div>
                </div>
            </div>
        </div>
        <small class="form-text text-muted mb-2">Filters are applied *before* sampling. If both title and line numbers are filled, title filter takes precedence.</small>
        <!-- END NEW FILTER FIELDS for Test Screening -->

        <button id="start_test_screen_button" type="button" class="btn gradient-btn btn-sm">
            <span id="test_spinner" class="spinner-border spinner-border-sm" role="status" aria-hidden="true" style="display: none;"></span>
            Start Test Screening
        </button>
    </form>
    {# RESTORED: Detailed HTML for Test progress area #}
    <div id="test_progress_area" class="mt-3" style="display: none;">
        <h4>Test Screening Progress:</h4>
        <div class="progress mb-2">
            <div id="test_progress_bar" class="progress-bar progress-bar-striped progress-bar-animated bg-info" role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
        </div>
        <p id="test_progress_status" class="mt-1 small text-muted"></p>
        <div id="test_progress_log_container" style="display:none;">
            <strong>Live Log (Test):</strong>
            <div id="test_progress_log" style="max-height: 100px; overflow-y: auto; font-size: 0.8em; background-color: #f0f0f0; padding: 8px; border: 1px solid #ccc; margin-top:8px; border-radius: 4px; white-space: pre-line;"></div>
        </div>
    </div>
     <div id="test_results_link_area" class="mt-3" style="display:none;">
        <a href="#" id="view_test_results_link" class="btn gradient-btn">View Test Results & Assess</a>
    </div>
</div>

{# --- Full Dataset (Abstracts) Screening Section --- #}
<div class="section-card">
    <h2 class="full-screening-title">Screen Full Dataset (Abstracts)</h2>
    <p>Upload your .ris file to screen all entries based on abstracts using the current settings. Progress is displayed live.</p>
    <form id="full_screen_form_id" enctype="multipart/form-data">
        <div class="form-group">
            <label for="full_file_progress">Upload RIS File:</label>
            <input type="file" name="file" id="full_file_progress" class="form-control-file form-control-sm" required accept=".ris">
        </div>

        <!-- NEW FILTER FIELDS -->
        <div class="form-row">
            <div class="form-group col-md-6">
                <label for="title_text_filter">Filter by Title (Optional):</label>
                <div class="input-group input-group-sm">
                    <input type="text" id="title_text_filter" name="title_text_filter" class="form-control form-control-sm" placeholder="Enter keywords from title">
                    <div class="input-group-append">
                        <button class="btn btn-outline-secondary clear-input-btn" type="button" onclick="clearInput('title_text_filter')">&times;</button>
                    </div>
                </div>
            </div>
            <div class="form-group col-md-6">
                <label for="line_range_filter">Filter by Line Numbers (Optional, 1-based):</label>
                <div class="input-group input-group-sm">
                    <input type="text" id="line_range_filter" name="line_range_filter" class="form-control form-control-sm" placeholder="e.g., 5-10, 7, 1-20, 50-">
                    <div class="input-group-append">
                        <button class="btn btn-outline-secondary clear-input-btn" type="button" onclick="clearInput('line_range_filter')">&times;</button>
                    </div>
                </div>
            </div>
        </div>
        <small class="form-text text-muted mb-2">If both title and line numbers are filled, title filter will take precedence.</small>
        <!-- END NEW FILTER FIELDS -->

        <div class="form-group mt-3">
            <button type="button" id="start_full_screen_button" class="btn gradient-btn btn-sm">
                Start Full Screening
                <span id="full_spinner" class="spinner-border spinner-border-sm" style="display: none;"></span>
            </button>
        </div>
    </form>
    {# RESTORED: Detailed HTML for Full progress area #}
     <div id="progress_area" class="mt-3" style="display: none;">
        <h4>Screening Progress:</h4>
        <div class="d-flex justify-content-between align-items-center mb-2">
            <div class="progress flex-grow-1 mr-2">
                <div id="progress_bar" class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
            </div>
            <button id="pause_resume_button" class="btn btn-warning btn-sm">Pause</button>
        </div>
        <p id="progress_status" class="mt-1 small text-muted"></p>
        <div id="progress_log_container" style="display:none;">
            <strong>Live Log:</strong>
            <div id="progress_log" style="max-height: 100px; overflow-y: auto; font-size: 0.8em; background-color: #f0f0f0; padding: 8px; border: 1px solid #ccc; margin-top:8px; border-radius: 4px; white-space: pre-line;"></div> {# Note: ID is progress_log #}
        </div>
    </div>
     <div id="sse_results_link_area" class="mt-3" style="display:none;">
        <a href="#" id="view_full_results_link" class="btn gradient-btn">View Full Results</a> 
    </div>
</div>

{% endblock %}

{% block extra_js %}
<script>
// Define MAX log items globally in the script block
const MAX_TEST_LOG_ITEMS = 5;
const MAX_FULL_LOG_ITEMS = 7;
const INIT_TIMEOUT_MS = 15000; // 15 seconds timeout for initialization phase

const RESULTS_HISTORY_KEY = 'metaScreenerResultsHistory';
const MAX_RESULTS_HISTORY_ITEMS = 10; // Max number of history items to keep

// --- Helper Functions (Refined - Get element inside) ---
function addTestLogItem(message) {
    const logEl = document.getElementById('test_progress_log'); 
    if(logEl) {
        // Use requestAnimationFrame for efficient DOM updates
        requestAnimationFrame(() => {
            const div = document.createElement('div');
            div.innerHTML = message;
            // Keep only the specified number of latest logs
            while (logEl.children.length >= MAX_TEST_LOG_ITEMS) { 
                logEl.removeChild(logEl.firstChild); 
            }
            
            // Check if user is already at the bottom before scrolling
            const isScrolledToBottom = logEl.scrollHeight - logEl.clientHeight <= logEl.scrollTop + 1;
            
            // Add the new log item
            logEl.appendChild(div);
            
            // Only auto-scroll if user was already at the bottom
            if (isScrolledToBottom) {
                logEl.scrollTop = logEl.scrollHeight;
            }
        });
    } else {
        if (!window.loggedTestLogError) { console.error('!!! testProgressLog element NOT found in addTestLogItem'); window.loggedTestLogError = true; }
    }
}

function addLogItem(message) {
    const logEl = document.getElementById('progress_log'); 
     if(logEl) {
        // Use requestAnimationFrame for efficient DOM updates
        requestAnimationFrame(() => {
            const div = document.createElement('div');
            div.innerHTML = message;
            // Keep only the specified number of latest logs
            while (logEl.children.length >= MAX_FULL_LOG_ITEMS) { 
                logEl.removeChild(logEl.firstChild); 
            }
            
            // Check if user is already at the bottom before scrolling
            const isScrolledToBottom = logEl.scrollHeight - logEl.clientHeight <= logEl.scrollTop + 1;
            
            // Add the new log item
            logEl.appendChild(div);
            
            // Only auto-scroll if user was already at the bottom
            if (isScrolledToBottom) {
                logEl.scrollTop = logEl.scrollHeight;
            }
        });
    } else {
        if (!window.loggedFullLogError) { console.error('!!! progressLog element NOT found in addLogItem'); window.loggedFullLogError = true; }
    }
}

// --- Finalize Button Functions --- 
function finalizeTestButton() { 
    const btn = document.getElementById('start_test_screen_button'); 
    if(btn) btn.disabled = false; 
    const spin = document.getElementById('test_spinner'); 
    if(spin) spin.style.display = 'none'; 
}

function finalizeFullButton() {
    const btn = document.getElementById('start_full_screen_button'); 
    if(btn) btn.disabled = false; 
    const spin = document.getElementById('full_spinner'); 
    if(spin) spin.style.display = 'none';
}

function finalizeButtons() { 
    finalizeFullButton();
    // finalizeTestButton(); // Maybe call this too if test button might also be disabled?
}

function clearInput(inputId) {
    const inputElement = document.getElementById(inputId);
    if (inputElement) {
        inputElement.value = '';
    }
}

function saveScreeningResultToHistory(screeningType, screeningId, fileName, totalItems, risContentForFilename) {
    if (!screeningId) {
        console.error("Screening ID is missing, cannot save to history.");
        return;
    }

    let history = JSON.parse(localStorage.getItem(RESULTS_HISTORY_KEY) || '[]');

    // Attempt to get a more reliable filename if 'fileName' is not directly available
    let actualFileName = fileName;
    if (!actualFileName && risContentForFilename) {
        // Basic extraction, assuming filename might be in a comment or specific field
        // This is a heuristic and might need refinement based on actual RIS format
        const match = risContentForFilename.match(/FN - (.*)/) || risContentForFilename.match(/DB - (.*)/) ;
        if (match && match[1]) {
            actualFileName = match[1].trim() + ".ris"; // Assuming .ris if extracted from content
        } else {
            actualFileName = "Unknown File";
        }
    } else if (!actualFileName) {
        actualFileName = "Unknown File";
    }


    const now = new Date();
    const timestamp = now.toISOString();
    const historyEntryName = `${screeningType} - ${actualFileName} (${totalItems} items) - ${now.toLocaleDateString()} ${now.toLocaleTimeString()}`;

    const newEntry = {
        id: screeningId,
        name: historyEntryName,
        type: screeningType,
        fileName: actualFileName,
        totalItems: totalItems,
        timestamp: timestamp,
        screeningId: screeningId // Redundant but keeps structure similar to criteria history if needed
    };

    // Add new entry to the beginning
    history.unshift(newEntry);

    // Limit history size
    if (history.length > MAX_RESULTS_HISTORY_ITEMS) {
        history = history.slice(0, MAX_RESULTS_HISTORY_ITEMS);
    }

    localStorage.setItem(RESULTS_HISTORY_KEY, JSON.stringify(history));
    console.log("Saved screening result to history:", newEntry);
}

document.addEventListener('DOMContentLoaded', function() {
    console.log("DOM loaded. Finding trigger elements...");
    const startTestScreenButton = document.getElementById('start_test_screen_button');
    const startFullScreenButton = document.getElementById('start_full_screen_button');
    console.log("Buttons found:", { startTestScreenButton, startFullScreenButton });
    window.loggedTestLogError = false; // Reset log error flags on load
    window.loggedFullLogError = false;

    // Initialize global variables for screening state
    window.screeningPaused = false;
    window.xhr = null; // Store the XHR object globally
    window.pausedData = {
        processedItems: [],
        resumePoint: 0
    };
    window.screeningResumeId = localStorage.getItem('screening_resume_id') || '';

    // --- Test Screening SSE Logic --- 
    if (startTestScreenButton) {
        startTestScreenButton.addEventListener('click', function() {
            console.log("Test Screen Button CLICKED!");
            const testFileInput = document.getElementById('test_file');
            const sampleSizeInput = document.getElementById('sample_size');
            const testTitleFilterInput = document.getElementById('test_title_text_filter');
            const testLineRangeInput = document.getElementById('test_line_range_filter');

            if (!testFileInput.files || testFileInput.files.length === 0) { alert('Please select a file for test screening.'); return; }
            const sampleSize = sampleSizeInput.value || 10;
            console.log(`Test Screening initiated. Sample size: ${sampleSize}`);

            // Reset UI
            const testProgressArea = document.getElementById('test_progress_area');
            const testProgressBar = document.getElementById('test_progress_bar');
            const testProgressStatus = document.getElementById('test_progress_status');
            const testProgressLogContainer = document.getElementById('test_progress_log_container');
            const testResultsLinkArea = document.getElementById('test_results_link_area');
            const testSpinner = document.getElementById('test_spinner');
            
            if(testProgressArea) testProgressArea.style.display = 'block';
            if(testProgressLogContainer) testProgressLogContainer.style.display = 'block';
            if(testSpinner) testSpinner.style.display = 'inline-block';
            
            // Clear logs
            const initialLogEl = document.getElementById('test_progress_log'); 
            if(initialLogEl) initialLogEl.innerHTML = '';
            
            if(testProgressBar) { 
                testProgressBar.style.width = '0%'; 
                testProgressBar.textContent = '0%'; 
                testProgressBar.classList.remove('bg-success', 'bg-danger'); 
                testProgressBar.classList.add('bg-info'); 
            }
            
            if(testProgressStatus) {
                testProgressStatus.textContent = 'Initializing test screening...';
                testProgressStatus.dataset.status = 'initializing';
            }
            
            if(testResultsLinkArea) testResultsLinkArea.style.display = 'none';
            startTestScreenButton.disabled = true;
            window.loggedTestLogError = false;

            // Simplified initialization timer
            let initTimer = null;
            let dots = '';
            
            initTimer = setInterval(() => {
                if (testProgressStatus && testProgressStatus.dataset.status === 'initializing') {
                    dots = dots.length >= 3 ? '' : dots + '.';
                    testProgressStatus.textContent = `Initializing test screening${dots}`;
                    
                    // Avoid frequent log updates
                    if (Math.floor(Math.random() * 5) === 0) { // Only 20% chance to add log
                        addTestLogItem(`[${new Date().toLocaleTimeString()}] File upload and processing in progress, please wait...`);
                    }
                } else {
                    clearInterval(initTimer);
                    initTimer = null;
                }
            }, 500);

            const formData = new FormData(); 
            formData.append('file', testFileInput.files[0]); 
            formData.append('sample_size', sampleSize);
            
            if (testTitleFilterInput && testTitleFilterInput.value) {
                formData.append('title_text_filter', testTitleFilterInput.value.trim());
            }
            if (testLineRangeInput && testLineRangeInput.value) {
                formData.append('line_range_filter', testLineRangeInput.value.trim());
            }

            const xhrTest = new XMLHttpRequest(); 
            console.log("Initiating Test XHR Request...");
            xhrTest.open("POST", "{{ url_for('stream_test_screen_file') }}", true);
            let lastTestCharIndex = 0;

            xhrTest.onprogress = function() {
                const newText = xhrTest.responseText.substring(lastTestCharIndex);
                lastTestCharIndex = xhrTest.responseText.length;
                if (!newText) return; // If no new content, return directly
                
                // 优化：使用requestAnimationFrame确保UI更新高效
                requestAnimationFrame(() => {
                    const messages = newText.split('\n\n');
                    for (const message of messages) {
                        if (message.startsWith("data: ")) {
                            try {
                                const jsonData = JSON.parse(message.substring(6));
                                
                                // Get needed DOM elements
                                const currentTestBar = document.getElementById('test_progress_bar');
                                const currentTestStatus = document.getElementById('test_progress_status');
                                const currentTestLinkArea = document.getElementById('test_results_link_area');
                                const currentTestLink = document.getElementById('view_test_results_link');

                                // Process event types
                                switch (jsonData.type) {
                                    case 'init':
                                        // Initialization event
                                        if(currentTestStatus) {
                                            currentTestStatus.textContent = jsonData.message || 'Processing upload, please wait...';
                                        }
                                        break;
                                    
                                    case 'start':
                                        // Clear initialization timer
                                        if (initTimer) {
                                            clearInterval(initTimer);
                                            initTimer = null;
                                        }
                                        
                                        if(currentTestStatus) {
                                            currentTestStatus.dataset.status = 'processing';
                                            currentTestStatus.textContent = 'Starting test screening...';
                                        }
                                        
                                        if(currentTestBar) { 
                                            currentTestBar.style.width = '0%'; 
                                            currentTestBar.textContent = '0%'; 
                                        }
                                        
                                        addTestLogItem(`[${new Date().toLocaleTimeString()}] Starting to screen ${jsonData.total} sampled entries.`);
                                        console.log(`Test screening started: ${jsonData.total} entries...`);
                                        break;
                                    
                                    case 'progress':
                                        if(currentTestBar) {
                                            const percentComplete = jsonData.percentage || Math.floor((jsonData.count / jsonData.total) * 100);
                                            currentTestBar.style.width = `${percentComplete}%`;
                                            currentTestBar.textContent = `${percentComplete}%`;
                                        }
                                        
                                        if(currentTestStatus) {
                                            currentTestStatus.textContent = `Screening ${jsonData.count} / ${jsonData.total}. Current: ${jsonData.current_item_title}`;
                                        }
                                        
                                        if (jsonData.decision) {
                                            let decisionClass = "";
                                            if(jsonData.decision === "INCLUDE") decisionClass = "include";
                                            else if(jsonData.decision === "EXCLUDE") decisionClass = "exclude";
                                            else if(jsonData.decision === "MAYBE") decisionClass = "maybe";
                                            else decisionClass = "error";
                                            
                                            // 序列号、标题、决定结果(带颜色)的统一格式
                                            const logMessage = `[${jsonData.count}] ${jsonData.current_item_title} - <span class="log-decision-${jsonData.decision}">${jsonData.decision}</span>`;
                                            addTestLogItem(logMessage);
                                        }
                                        break;
                                    
                                    case 'status':
                                        // 添加状态更新处理
                                        if(currentTestStatus && jsonData.message) {
                                            currentTestStatus.textContent = jsonData.message;
                                        }
                                        break;
                                    
                                    case 'complete':
                                        if(currentTestBar) { 
                                            currentTestBar.classList.add('bg-success'); 
                                            currentTestBar.textContent = "Complete"; 
                                        }
                                        
                                        if(currentTestStatus) {
                                            currentTestStatus.textContent = jsonData.message || 'Test screening complete.';
                                        }
                                        
                                        addTestLogItem(`[${new Date().toLocaleTimeString()}] ${jsonData.message || 'Test screening complete.'}`);
                                        
                                        if (jsonData.session_id && currentTestLink && currentTestLinkArea) {
                                            let baseUrl = "{{ url_for('show_test_results', session_id='__SESSION_ID__') }}";
                                            currentTestLink.href = baseUrl.replace('__SESSION_ID__', jsonData.session_id);
                                            currentTestLinkArea.style.display = 'block';
                                        }
                                        
                                        try { xhrTest.abort(); } catch (e) { console.warn("Error aborting test XHR:", e); }
                                        finalizeTestButton();
                                        saveScreeningResultToHistory('Test Abstract Screening', jsonData.session_id, jsonData.filename, jsonData.total, jsonData.ris_content);
                                        break;
                                    
                                    case 'error':
                                        // Clear initialization timer
                                        if (initTimer) {
                                            clearInterval(initTimer);
                                            initTimer = null;
                                        }
                                        
                                        if(currentTestBar) { 
                                            currentTestBar.classList.add('bg-danger'); 
                                            currentTestBar.textContent = "Error"; 
                                        }
                                        
                                        if(currentTestStatus) {
                                            currentTestStatus.textContent = `Error: ${jsonData.message}`;
                                        }
                                        
                                        let testErrorMessage = `[${new Date().toLocaleTimeString()}] Error: ${jsonData.message}`;
                                        if (jsonData.needs_config) {
                                            const configUrl = "{{ url_for('llm_config_page') }}";
                                            testErrorMessage += ` <a href="${configUrl}" target="_blank">Please configure API Key.</a>`;
                                        }
                                        
                                        addTestLogItem(testErrorMessage);
                                        try { xhrTest.abort(); } catch (e) { console.warn("Error aborting test XHR:", e); }
                                        finalizeTestButton();
                                        break;
                                }
                                
                            } catch (e) { 
                                console.error("Test SSE parse error:", e, "Original message:", message); 
                                finalizeTestButton();
                            } 
                        }
                    }
                });
            }; 
            
            xhrTest.onloadend = function() { 
                // Clear initialization timer
                if (initTimer) {
                    clearInterval(initTimer);
                    initTimer = null;
                }
                
                const currentTestLinkArea = document.getElementById('test_results_link_area');
                const currentTestLink = document.getElementById('view_test_results_link');
                
                if (xhrTest.responseText && xhrTest.responseText.includes('"session_id"') && 
                    currentTestLinkArea && currentTestLinkArea.style.display === 'none') {
                    try {
                        const match = xhrTest.responseText.match(/"session_id":"([^"]+)"/);
                        if (match && match[1] && currentTestLink) {
                            let baseUrl = "{{ url_for('show_test_results', session_id='__SESSION_ID__') }}";
                            currentTestLink.href = baseUrl.replace('__SESSION_ID__', match[1]);
                            currentTestLinkArea.style.display = 'block';
                        }
                    } catch (e) {
                        console.error("Error setting up test results link in onloadend:", e);
                    }
                }
                
                finalizeTestButton(); 
            }; 
            
            xhrTest.onerror = function() { 
                // Clear initialization timer
                if (initTimer) {
                    clearInterval(initTimer);
                    initTimer = null;
                }
                
                addTestLogItem(`[${new Date().toLocaleTimeString()}] Network error occurred during test screening.`);
                finalizeTestButton(); 
            }; 
            
            xhrTest.send(formData);
        }); 
    }

    // --- Full Screening SSE Logic ---
    if (startFullScreenButton) {
        startFullScreenButton.addEventListener('click', function() {
             console.log(">>> Full Screen Button CLICKED!");
             const fileInput = document.getElementById('full_file_progress');
             if (!fileInput || !fileInput.files || fileInput.files.length === 0) { alert('Please select file...'); return; }
             console.log("Full screening initiated.");
             
             // Reset UI and data
             resetFullScreeningUI();
             
             const formData = new FormData(); 
             formData.append('file', fileInput.files[0]);
             const titleFilterInput = document.getElementById('title_text_filter');
             const lineRangeInput = document.getElementById('line_range_filter');
             
             if (titleFilterInput && titleFilterInput.value) {
                 formData.append('title_text_filter', titleFilterInput.value.trim());
             }
             
             if (lineRangeInput && lineRangeInput.value) {
                 formData.append('line_range_filter', lineRangeInput.value.trim());
             }
             
             // Create XHR request and store it globally
             window.xhr = new XMLHttpRequest();
             window.xhr.open('POST', '{{ url_for("stream_screen_file") }}', true);
             window.xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
             
             // Set up event listeners
             setupFullScreeningXHREventListeners(window.xhr);
             
             // Send the request
             window.xhr.send(formData);
        });
    }

    // Add listener for pause/resume button
    const pauseResumeButton = document.getElementById('pause_resume_button');
    if (pauseResumeButton) {
        pauseResumeButton.addEventListener('click', function() {
            if (window.screeningPaused) {
                // Resume processing
                resumeScreening();
            } else {
                // Pause processing
                pauseScreening();
            }
        });
    }

    function pauseScreening() {
        if (!window.xhr) return;
        
        // Update UI
        window.screeningPaused = true;
        pauseResumeButton.textContent = 'Resume';
        pauseResumeButton.classList.remove('btn-warning');
        pauseResumeButton.classList.add('btn-success');
        
        // Add log entry
        addLogItem(`[${new Date().toLocaleTimeString()}] Screening paused by user.`);
        
        // Cancel current XHR request
        if (window.xhr) {
            try { 
                window.xhr.abort(); 
            } catch (e) { 
                console.warn("Error aborting XHR:", e); 
            }
        }
        
        // Save ALL screening data to localStorage
        try {
            // Verify that we have actual data to save
            if (!window.pausedData || !window.pausedData.processedItems || window.pausedData.processedItems.length === 0) {
                addLogItem(`[${new Date().toLocaleTimeString()}] Warning: No processed items available to save.`);
                console.warn("No processed items available in window.pausedData");
            }
            
            // Before saving, verify all indices are unique in processedItems
            const seenIndices = new Set();
            const uniqueProcessedItems = [];
            
            // Deduplicate based on index
            for (const item of window.pausedData.processedItems) {
                if (item && item.index && !seenIndices.has(item.index)) {
                    seenIndices.add(item.index);
                    uniqueProcessedItems.push(item);
                }
            }
            
            // Sort by index for consistency
            uniqueProcessedItems.sort((a, b) => a.index - b.index);
            
            // Create a complete screening state object
            const fullScreeningState = {
                // Current processing position - critical for resume
                resume_point: window.pausedData.resumePoint,
                
                // Store ALL processed items, not just the last few
                // This ensures we don't lose any data when resuming
                processed_items: uniqueProcessedItems,
                
                // Store filtering information
                title_filter: document.getElementById('title_text_filter')?.value || '',
                line_range: document.getElementById('line_range_filter')?.value || '',
                
                // Add timestamp for debugging
                timestamp: new Date().toISOString(),
                
                // Add a session identifier
                session_id: `pause_${Date.now()}`
            };
            
            // Store the complete state
            localStorage.setItem('full_screening_state', JSON.stringify(fullScreeningState));
            
            // Log state summary
            const indexRanges = uniqueProcessedItems.length > 0 ? 
                `indices ${uniqueProcessedItems[0].index}-${uniqueProcessedItems[uniqueProcessedItems.length-1].index}` : 
                "no items";
                
            console.log("Successfully saved complete screening state to localStorage", {
                resume_point: fullScreeningState.resume_point,
                processed_items_count: fullScreeningState.processed_items.length,
                timestamp: fullScreeningState.timestamp,
                index_ranges: indexRanges
            });
            
            // Update UI with success message
            const progressStatus = document.getElementById('progress_status');
            if (progressStatus) {
                progressStatus.textContent = `Screening paused at item ${fullScreeningState.resume_point}. All data saved locally.`;
            }
            
            addLogItem(`[${new Date().toLocaleTimeString()}] Pause successful. All data saved locally. Position: ${fullScreeningState.resume_point}, Items: ${fullScreeningState.processed_items.length}, ${indexRanges}`);
        } catch (e) {
            console.error("Error saving screening state to localStorage:", e);
            addLogItem(`[${new Date().toLocaleTimeString()}] Warning: Could not save complete state locally: ${e.message}`);
            
            const progressStatus = document.getElementById('progress_status');
            if (progressStatus) {
                progressStatus.textContent = 'Screening paused but state could not be saved.';
            }
        }
    }

    function resumeScreening() {
        window.screeningPaused = false;
        pauseResumeButton.textContent = 'Pause';
        pauseResumeButton.classList.remove('btn-success');
        pauseResumeButton.classList.add('btn-warning');
        
        addLogItem(`[${new Date().toLocaleTimeString()}] Attempting to resume screening...`);
        
        // Re-upload the file
        const fileInput = document.getElementById('full_file_progress');
        if (!fileInput || !fileInput.files || fileInput.files.length === 0) {
            alert('Please select the file again to resume screening.');
            return;
        }
        
        // Try to load the complete saved state
        let savedState = null;
        let actualResumePoint = 0;
        let previouslyProcessedItems = [];
        
        try {
            const storedData = localStorage.getItem('full_screening_state');
            if (storedData) {
                savedState = JSON.parse(storedData);
                console.log("Found saved screening state:", {
                    resume_point: savedState.resume_point,
                    processed_items_count: savedState.processed_items?.length || 0,
                    timestamp: savedState.timestamp
                });
                
                // Validate resume point
                if (savedState.resume_point && !isNaN(savedState.resume_point) && savedState.resume_point > 0) {
                    actualResumePoint = savedState.resume_point;
                    
                    // Ensure we have processed items array
                    if (savedState.processed_items && Array.isArray(savedState.processed_items)) {
                        previouslyProcessedItems = savedState.processed_items;
                        
                        // Log details for debugging
                        const processedIndices = previouslyProcessedItems.map(item => item.index).sort((a, b) => a - b);
                        addLogItem(`[${new Date().toLocaleTimeString()}] Resuming from position ${actualResumePoint} with ${previouslyProcessedItems.length} previously processed items (indices: ${processedIndices.slice(0, 5)}${processedIndices.length > 5 ? '...' + processedIndices.slice(-5).join(',') : ''})`)
                        console.log('Will resume from point:', actualResumePoint, 'with processed indices:', processedIndices);
                    } else {
                        console.warn("Saved state has valid resume point but missing or invalid processed_items array");
                        addLogItem(`[${new Date().toLocaleTimeString()}] Warning: Resume point found (${actualResumePoint}) but no valid processed items. May lose previous results.`);
                    }
                } else {
                    console.warn("Invalid or missing resume point in saved state:", savedState.resume_point);
                    addLogItem(`[${new Date().toLocaleTimeString()}] Warning: Invalid resume point in saved state.`);
                }
            } else {
                console.warn("No saved screening state found in localStorage");
                addLogItem(`[${new Date().toLocaleTimeString()}] No saved screening state found.`);
            }
        } catch (e) {
            console.error("Error loading saved screening state:", e);
            addLogItem(`[${new Date().toLocaleTimeString()}] Error loading saved state: ${e.message}`);
        }
        
        // If no localStorage data, try window.pausedData as fallback
        if (actualResumePoint === 0 && window.pausedData && window.pausedData.resumePoint > 0) {
            actualResumePoint = window.pausedData.resumePoint;
            previouslyProcessedItems = window.pausedData.processedItems || [];
            
            addLogItem(`[${new Date().toLocaleTimeString()}] Using in-memory data for resume: position ${actualResumePoint}, items: ${previouslyProcessedItems.length}`);
            console.log('Using in-memory data:', {
                resumePoint: actualResumePoint,
                itemsCount: previouslyProcessedItems.length
            });
        }
        
        // Safety check - ensure resumePoint is either 0 (restart) or matches the length of processed items
        // This prevents the case where resumePoint is ahead of actual processed items
        if (actualResumePoint > 0 && previouslyProcessedItems.length > 0) {
            // If these values don't match, something is wrong
            if (Math.abs(actualResumePoint - previouslyProcessedItems.length) > 1) {
                console.warn(`Resume point (${actualResumePoint}) does not match processed items count (${previouslyProcessedItems.length})`);
                addLogItem(`[${new Date().toLocaleTimeString()}] Warning: Resume point and processed items count mismatch - adjusting to prevent data loss`);
                
                // Use the minimum of the two to ensure we don't skip any items
                actualResumePoint = Math.min(actualResumePoint, previouslyProcessedItems.length);
                
                // Sort processed items by index to ensure proper order
                previouslyProcessedItems.sort((a, b) => a.index - b.index);
            }
        }
        
        // Build form data for resuming
        const formData = new FormData();
        formData.append('file', fileInput.files[0]);
        
        // Add resume parameters
        formData.append('resume', 'true');
        formData.append('resume_from', actualResumePoint.toString());
        
        // Add processed items - but be careful about size limits
        if (previouslyProcessedItems.length > 0) {
            try {
                // Try to send ALL previously processed items
                // If this causes 413 errors, we might need to limit the size
                const processedDataString = JSON.stringify(previouslyProcessedItems);
                
                // If data is very large, log a warning but still try to send it
                if (processedDataString.length > 1000000) { // 1MB
                    console.warn(`Processed data is very large: ${processedDataString.length} bytes`);
                    addLogItem(`[${new Date().toLocaleTimeString()}] Warning: Large amount of data to restore (${previouslyProcessedItems.length} items, ${Math.round(processedDataString.length/1024)} KB)`);
                }
                
                formData.append('processed_data', processedDataString);
            } catch (e) {
                console.error("Error adding processed items to form data:", e);
                addLogItem(`[${new Date().toLocaleTimeString()}] Error preparing processed items: ${e.message}`);
            }
        } else if (actualResumePoint > 0) {
            addLogItem(`[${new Date().toLocaleTimeString()}] Warning: Resuming from position ${actualResumePoint} but no processed items available.`);
        }
        
        // Add filters from saved state or UI
        let titleFilter = '';
        let lineRange = '';
        
        // First try to get filters from saved state
        if (savedState) {
            titleFilter = savedState.title_filter || '';
            lineRange = savedState.line_range || '';
        }
        
        // Then check UI fields which take precedence
        const titleFilterInput = document.getElementById('title_text_filter');
        if (titleFilterInput && titleFilterInput.value) {
            titleFilter = titleFilterInput.value.trim();
        } else if (titleFilter && titleFilterInput) {
            // If we have a saved filter but UI field is empty, update the UI
            titleFilterInput.value = titleFilter;
        }
        
        const lineRangeInput = document.getElementById('line_range_filter');
        if (lineRangeInput && lineRangeInput.value) {
            lineRange = lineRangeInput.value.trim();
        } else if (lineRange && lineRangeInput) {
            // If we have a saved range but UI field is empty, update the UI
            lineRangeInput.value = lineRange;
        }
        
        // Add filters to form data
        if (titleFilter) {
            formData.append('title_text_filter', titleFilter);
        }
        
        if (lineRange) {
            formData.append('line_range_filter', lineRange);
        }
        
        // Update UI to show status
        const progressStatus = document.getElementById('progress_status');
        if (progressStatus) {
            if (actualResumePoint > 0) {
                progressStatus.textContent = `Resuming from item ${actualResumePoint} with ${previouslyProcessedItems.length} previous results...`;
            } else {
                progressStatus.textContent = 'No valid resume point found. Starting new screening...';
            }
        }
        
        // Log final resume parameters for debugging
        console.log('Final resume parameters:', {
            resume: true,
            resume_from: actualResumePoint,
            processed_items_count: previouslyProcessedItems.length,
            title_filter: titleFilter,
            line_range: lineRange
        });
        
        // Create XHR request and send
        window.xhr = new XMLHttpRequest();
        window.xhr.open('POST', '{{ url_for("stream_screen_file") }}', true);
        window.xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
        
        // Set up event listeners
        setupFullScreeningXHREventListeners(window.xhr);
        
        // Send the request
        window.xhr.send(formData);
    }

    function resetFullScreeningUI() {
        const progressArea = document.getElementById('progress_area');
        const progressLogContainer = document.getElementById('progress_log_container');
        const progressBar = document.getElementById('progress_bar');
        const progressStatus = document.getElementById('progress_status');
        const sseResultsLinkArea = document.getElementById('sse_results_link_area');
        const pauseResumeButton = document.getElementById('pause_resume_button');
        
        // Reset the pausedData for a new session
        window.pausedData = {
            processedItems: [],
            resumePoint: 0
        };
        
        // Clear ALL stored state for a fresh start
        window.screeningResumeId = '';
        localStorage.removeItem('screening_resume_id');
        localStorage.removeItem('screening_paused_data'); // Legacy key
        localStorage.removeItem('full_screening_state'); // New key
        
        if(progressArea) progressArea.style.display = 'block';
        if(progressLogContainer) progressLogContainer.style.display = 'block';
        
        // Reset pause/resume button
        if(pauseResumeButton) {
            pauseResumeButton.textContent = 'Pause';
            pauseResumeButton.classList.remove('btn-success');
            pauseResumeButton.classList.add('btn-warning');
        }
        
        // Clear logs
        const initialFullLogEl = document.getElementById('progress_log'); 
        if(initialFullLogEl) initialFullLogEl.innerHTML = '';
        
        if(progressBar) {
            progressBar.style.width = '0%'; 
            progressBar.textContent = '0%'; 
            progressBar.classList.remove('bg-success','bg-danger');
        }
        
        if(progressStatus) {
            progressStatus.textContent = 'Initializing new screening session...';
            progressStatus.dataset.status = 'initializing';
        }
        
        if(sseResultsLinkArea) sseResultsLinkArea.style.display = 'none';
        startFullScreenButton.disabled = true;
        const fullSpinner = document.getElementById('full_spinner');
        if(fullSpinner) fullSpinner.style.display = 'inline-block';
        window.loggedFullLogError = false;
    }

    function setupFullScreeningXHREventListeners(xhr) {
        // Add event listeners for SSE progress
        let buffer = '';
        
        xhr.onprogress = function() {
            let currentFullBar = document.getElementById('progress_bar');
            let currentFullStatus = document.getElementById('progress_status');
            let currentFullLinkArea = document.getElementById('sse_results_link_area');
            let currentFullLink = document.getElementById('view_full_results_link');
            
            if (window.screeningPaused) return; // Don't process events while paused
            
            buffer += xhr.responseText.substr(buffer.length);
            const messages = buffer.split('\n\n');
            buffer = messages.pop(); // Keep the last incomplete chunk
            
            for (const message of messages) {
                if (message.startsWith("data: ")) {
                    try {
                        const jsonData = JSON.parse(message.substring(6));
                        
                        // Process event types
                        switch (jsonData.type) {
                            case 'init':
                                // Initialization event
                                if(currentFullStatus) {
                                    currentFullStatus.textContent = jsonData.message || 'Processing upload, please wait...';
                                }
                                break;
                            
                            case 'start':
                                // Clear initialization timer (if exists)
                                if (window.initTimer) {
                                    clearInterval(window.initTimer);
                                    window.initTimer = null;
                                }
                                
                                if(currentFullStatus) {
                                    currentFullStatus.dataset.status = 'processing';
                                    currentFullStatus.textContent = 'Starting full screening...';
                                }
                                
                                if(currentFullBar) { 
                                    currentFullBar.style.width = '0%'; 
                                    currentFullBar.textContent = '0%'; 
                                }
                                
                                addLogItem(`[${new Date().toLocaleTimeString()}] Starting to screen ${jsonData.total} items.`);
                                break;
                            
                            case 'progress':
                                if (jsonData.percentage !== undefined && currentFullBar) {
                                    currentFullBar.style.width = jsonData.percentage + '%';
                                    currentFullBar.textContent = jsonData.percentage + '%';
                                    currentFullBar.setAttribute('aria-valuenow', jsonData.percentage);
                                }
                                
                                // Store progress for resume - 确保正确更新恢复点
                                if (jsonData.count !== undefined) {
                                    // Update in-memory resume point
                                    window.pausedData.resumePoint = jsonData.count;
                                    
                                    // Also update stored state if it exists
                                    try {
                                        const storedStateStr = localStorage.getItem('full_screening_state');
                                        if (storedStateStr) {
                                            const storedState = JSON.parse(storedStateStr);
                                            storedState.resume_point = jsonData.count;
                                            localStorage.setItem('full_screening_state', JSON.stringify(storedState));
                                        }
                                    } catch (e) {
                                        console.warn("Could not update resume point in localStorage:", e);
                                    }
                                }
                                
                                // Store processed item data for potential pause/resume
                                if (jsonData.item_data) {
                                    // Ensure item_data has valid index property
                                    if (!jsonData.item_data.index) {
                                        console.warn("Received item_data without index:", jsonData.item_data);
                                        // Try to infer index from count if available
                                        if (jsonData.count) {
                                            jsonData.item_data.index = jsonData.count;
                                        }
                                    }
                                    
                                    // 防止重复添加到processedItems - 使用索引作为唯一标识
                                    const itemIndex = jsonData.item_data.index;
                                    
                                    if (itemIndex) {
                                        // 检查是否已经存在相同索引的项目
                                        const existingItemIndex = window.pausedData.processedItems.findIndex(
                                            item => item && item.index === itemIndex
                                        );
                                        
                                        if (existingItemIndex >= 0) {
                                            // 如果已存在，则替换
                                            console.log(`Replacing existing item with index ${itemIndex}`);
                                            window.pausedData.processedItems[existingItemIndex] = jsonData.item_data;
                                        } else {
                                            // 否则添加新项目
                                            window.pausedData.processedItems.push(jsonData.item_data);
                                            
                                            // Periodically check for missing indices
                                            if (window.pausedData.processedItems.length % 20 === 0) {
                                                const seenIndices = new Set(window.pausedData.processedItems.map(item => item.index));
                                                const expectedIndices = Array.from({length: window.pausedData.resumePoint}, (_, i) => i + 1);
                                                const missingIndices = expectedIndices.filter(idx => !seenIndices.has(idx));
                                                
                                                if (missingIndices.length > 0) {
                                                    console.warn(`Missing indices detected: ${missingIndices.join(', ')}`);
                                                }
                                            }
                                        }
                                    } else {
                                        console.warn("Cannot add item_data without valid index");
                                    }
                                    
                                    // No need to update localStorage on every item - that's inefficient
                                    // We'll update the full state when pausing
                                }
                                
                                if (jsonData.current_item_title) {
                                    const statusText = `Processing: ${jsonData.count}/${jsonData.total} - Current: "${jsonData.current_item_title}"`;
                                    if(currentFullStatus) currentFullStatus.textContent = statusText;
                                }
                                
                                // Add log entry for each processed item with decision if available
                                if (jsonData.decision) {
                                    let decisionClass = "";
                                    if(jsonData.decision === "INCLUDE") decisionClass = "include";
                                    else if(jsonData.decision === "EXCLUDE") decisionClass = "exclude";
                                    else if(jsonData.decision === "MAYBE") decisionClass = "maybe";
                                    else decisionClass = "error";
                                    
                                    // Format log message with item number, title and decision
                                    const logMessage = `[${jsonData.count}] ${jsonData.current_item_title} - <span class="log-decision-${decisionClass}">${jsonData.decision}</span>`;
                                    addLogItem(logMessage);
                                }
                                break;
                                
                            case 'status':
                                // Add status update handling
                                if(currentFullStatus && jsonData.message) {
                                    currentFullStatus.textContent = jsonData.message;
                                }
                                break;
                            
                            case 'complete':
                                if(currentFullBar) { 
                                    currentFullBar.classList.add('bg-success'); 
                                    currentFullBar.textContent = "Complete"; 
                                }
                                
                                if(currentFullStatus) {
                                    currentFullStatus.textContent = jsonData.message || 'Full screening complete.';
                                }
                                
                                addLogItem(`[${new Date().toLocaleTimeString()}] ${jsonData.message || 'Full screening complete.'}`);
                                
                                if (jsonData.screening_id && currentFullLink && currentFullLinkArea) {
                                    let baseUrl = "{{ url_for('show_screening_results', screening_id='__SCREENING_ID__') }}";
                                    currentFullLink.href = baseUrl.replace('__SCREENING_ID__', jsonData.screening_id);
                                    currentFullLinkArea.style.display = 'block';
                                }
                                
                                try { xhr.abort(); } catch (e) { console.warn("Error aborting full screening XHR:", e); }
                                finalizeButtons();
                                saveScreeningResultToHistory('Full Abstract Screening', jsonData.screening_id, jsonData.filename, jsonData.total, jsonData.ris_content);
                                
                                // Clear all screening state completely after successful completion
                                window.pausedData = { processedItems: [], resumePoint: 0 };
                                window.screeningResumeId = '';
                                localStorage.removeItem('screening_resume_id');
                                localStorage.removeItem('screening_paused_data');
                                localStorage.removeItem('full_screening_state');
                                
                                addLogItem(`[${new Date().toLocaleTimeString()}] Cleared all pause/resume data - screening complete.`);
                                break;
                            
                            case 'error':
                                if(currentFullBar) { 
                                    currentFullBar.classList.add('bg-danger'); 
                                    currentFullBar.textContent = "Error"; 
                                }
                                
                                if(currentFullStatus) {
                                    currentFullStatus.textContent = `Error: ${jsonData.message}`;
                                }
                                
                                let errorMessage = `[${new Date().toLocaleTimeString()}] Error: ${jsonData.message}`;
                                if (jsonData.needs_config) {
                                    const configUrl = "{{ url_for('llm_config_page') }}";
                                    errorMessage += ` <a href="${configUrl}" target="_blank">Please configure API Key.</a>`;
                                }
                                
                                addLogItem(errorMessage);
                                try { xhr.abort(); } catch (e) { console.warn("Error aborting full screening XHR:", e); }
                                finalizeButtons();
                                break;
                        }
                        
                    } catch (e) { 
                        console.error("Full SSE parse error:", e, "Original message:", message); 
                        finalizeButtons();
                    } 
                }
            }
        };

        // Handle completion of request
        xhr.onloadend = function() {
            if (window.screeningPaused) return; // Don't handle onloadend while paused
            
            const currentFullLinkArea = document.getElementById('sse_results_link_area');
            const currentFullLink = document.getElementById('view_full_results_link');
            
            if (xhr.responseText && xhr.responseText.includes('"screening_id"') && 
                currentFullLinkArea && currentFullLinkArea.style.display === 'none') {
                try {
                    const match = xhr.responseText.match(/"screening_id":"([^"]+)"/);
                    if (match && match[1] && currentFullLink) {
                        let baseUrl = "{{ url_for('show_screening_results', screening_id='__SCREENING_ID__') }}";
                        currentFullLink.href = baseUrl.replace('__SCREENING_ID__', match[1]);
                        currentFullLinkArea.style.display = 'block';
                    }
                } catch (e) {
                    console.error("Error setting up full screening results link in onloadend:", e);
                }
            }
            
            finalizeButtons();
        };
        
        // Handle network errors
        xhr.onerror = function() {
            if (window.screeningPaused) return; // Don't handle onerror while paused
            
            addLogItem(`[${new Date().toLocaleTimeString()}] Network error occurred during screening.`);
            finalizeButtons();
        };
    }
});
</script>
{% endblock %}